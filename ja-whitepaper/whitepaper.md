CryptoNote v 2.0
Nicolas van Saberhagen
October 17, 2013
# 1 イントロダクション
 "ビットコイン"[1]はp2pの電子マネーとしてのコンセプトを実装した成功例である。専門家も一般人も、公開トランザクションとproof-of-workの有益な組み合わせを信頼されたモデルとして評価するようになった。今日、電子マネーのユーザー基盤は順調なペースで伸びている。顧客は少ない手数料と、匿名性によって魅了され、商人は、非中央集権的に発行され、発行総量が予測されている事を評価している。ビットコインは、電子マネーが紙幣のように簡単で、クレジットカードのように便利であることを効果的に証明した。
　残念ながらビットコインはいくつかの問題に悩まされている。例えば、システムの分散型の性質は柔軟でなく、ほとんど全てのネットワークユーザーがクライアントソフトウェアをアップデートするまで新機能の実装が妨げられる。ビットコインが大きく広まる妨げになる、すぐには修正できない重大な問題がある。そのような柔軟でないモデルでは、オリジナルのモデルを永久的に修正するよりも、新しいプロジェクトを立ち上げる方が効率的です。
 この論文では、私たちはビットコインの主要な問題を研究して解決策を提案する。我々が提案する解決策を考慮したシステムは他の電子マネーシステムと健全な競争を生み出すと考えている。我々が自身の電子マネー"CryptoNote"を提案する。電子マネーにおいて次のブレークスルーを起こす名前である。

# 2 ビットコインの欠点と可能な解決策
## 2.1 トランザクションのトレーサビリティ
プライバシーと匿名性は電子マネーのもっとも重要な側面である。ピアツーピア決済は第三者の目から隠すことを望んできており、伝統的な銀行と比較して明確な違いである。特に、T.OkamotoとK.Ohtaは理想的な電子マネーとして6つの指標を"privacy: relationship between the user and his purchases must be untraceableby anyone [30]."の中で定義した。彼らの記述から、完全に匿名な電子マネーモデルが、OkamotoとOhtaが概説した要件を充足させるために充たさなければならない二つの特性を導いた。
 追跡不能性(Untraceability): それぞれの受領トランザクションにおいて、送金者であると見込まれる可能性は誰であっても等確率であること。
 リンク不可能性(Unlinkability): どの二つの出金トランザクションにおいても、それらが同じ人から送られたと証明することは不可能であること。
残念ながら、ビットコインは追跡不能性を満たしていません。

# 4 追跡不可能なトランザクション
## 4.1 文献レビュー
## 4.2 定義
## 4.3 リンク不可能な支払

## 4.4 ワンタイムリング署名
ワンタイムリング署名に基づいたプロトコルによって、リンク不可能性を達成する。残念ながら、普通の署名においては追跡を可能にしてしまう。この問題に対する我々の解決策は、通常電子マネーシステムにおいて使われるものとは異なる署名方式を用いることである。まず、我々は明示的に電子マネーシステムを参照することなく、アルゴリズムの概要を説明する。ワンタイムリング署名には、（GEN、SIG、VER、LNK）の4つのアルゴリズムが含まれる。
GEN: 公開パラメータを取得し、ecペア（P; x）と公開鍵Iを出力する
SIG: メッセージm、公開鍵{Pi}i≠s,ペア（Ps; xs）を取り、署名σと集合S = S' U {Ps}
VER: メッセージm、セットS、署名σをとり、TRUEまたはFALSEを出力する
LNK: _I_ = {Ii}, 署名σをとり、リンクされたか(linked)と独立(indep)を出力する

プロトコルの背後にあるアイデアはかなり単純である：ユーザは一意の公開鍵ではなく、公開鍵のセットによってチェックできる署名を生成する。 署名者の身元は、所有者が同じ鍵ペアを使用して2番目の署名を生成するまで、公開鍵が設定されている他のユーザと区別できない。

GEN: 署名者は、ランダムな秘密鍵x ∈ [1; l - 1]を計算し、対応する公開鍵P = xGを計算する。 さらに署名者は、key imageと呼ぶ別の公開鍵I = xHp（P）を計算する。
SIG: 署名者は[21]の手法を用いて、非対話型のゼロ知識証明でワンタイムリング署名を生成する。 署名者は、他のユーザの公開鍵Pi、自分の鍵ペア（x; P）およびkey image Iから、nのランダムなサブセットS'を選択する。 0 ≦ s ≦ nの署名者の秘密インデックスSである（その公開鍵がPsであるように）。署名者はランダムな{qi | i = 0 ...n} と、{wi | i = 0 ... n, i ≠ s}を(1 ... l)から取り、次の変換にて申請する

次のステップでは、非対話型の課題を取得する。
  c = Hs(m, L1, ... Ln;R1 ... Rn)

VER: 検証者は署名を以下の逆変換によってチェックする

最終的に、検証者は

<img src="https://latex.codecogs.com/gif.latex?\sum_{i=0}^{n}&space;ci=Hs(m,{L'_{0}},....{L'_{n}},{R'_{0}},....{R'_{n}})&space;\mod&space;l" />

を検証する。等式が正しければ、検証者はLNKアルゴリズムを実行し、等式が誤っていれば署名を拒否する。

LNK：署名者はIが過去の署名で使用されているかどうかをチェックします（これらの値は集合Iに格納される）。 複数の使用は、同じ秘密鍵で2つの署名が作成されたことを意味する。
プロトコルの意味：L変換を適用することによって、署名者は、少なくとも1つのPi = xGであることを彼が知っていることを証明する。 この証明を反復不可能にするために、I = xHp（P）としてキー画像を導入する。 署名者は、同じ文を証明するために同じ係数（ri; ci）を使用する。
署名者は、少なくとも1つのHp（Pi）= <img src="https://latex.codecogs.com/gif.latex?I\cdot&space;x^{-1}" >である事を知っている。
もしマッピング<img src="https://latex.codecogs.com/gif.latex?x\rightarrow&space;I" >を挿入したとして

1.誰もキーイメージから公開鍵を復元して、署名者を特定することはできない
2.署名者は、異なるIと同じxを持つ2つの署名を作ることはできない
完全なセキュリティ分析はAppendix Aにある。