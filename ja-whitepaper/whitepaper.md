CryptoNote v 2.0
Nicolas van Saberhagen
October 17, 2013
# 1 イントロダクション
 "ビットコイン"[1]はp2pの電子マネーとしてのコンセプトを実装した成功例である。専門家も一般人も、公開トランザクションとproof-of-workの有益な組み合わせを信頼されたモデルとして評価するようになった。今日、電子マネーのユーザー基盤は順調なペースで伸びている。顧客は少ない手数料と、匿名性によって魅了され、商人は、非中央集権的に発行され、発行総量が予測されている事を評価している。ビットコインは、電子マネーが紙幣のように簡単で、クレジットカードのように便利であることを効果的に証明した。
　残念ながらビットコインはいくつかの問題に悩まされている。例えば、システムの分散型の性質は柔軟でなく、ほとんど全てのネットワークユーザーがクライアントソフトウェアをアップデートするまで新機能の実装が妨げられる。ビットコインが大きく広まる妨げになる、すぐには修正できない重大な問題がある。そのような柔軟でないモデルでは、オリジナルのモデルを永久的に修正するよりも、新しいプロジェクトを立ち上げる方が効率的です。
 この論文では、私たちはビットコインの主要な問題を研究して解決策を提案する。我々が提案する解決策を考慮したシステムは他の電子マネーシステムと健全な競争を生み出すと考えている。我々が自身の電子マネー"CryptoNote"を提案する。電子マネーにおいて次のブレークスルーを起こす名前である。

# 2 ビットコインの欠点と可能な解決策
## 2.1 トランザクションのトレーサビリティ
プライバシーと匿名性は電子マネーのもっとも重要な側面である。ピアツーピア決済は第三者の目から隠すことを望んできており、伝統的な銀行と比較して明確な違いである。特に、T.OkamotoとK.Ohtaは理想的な電子マネーとして6つの指標を"privacy: relationship between the user and his purchases must be untraceableby anyone [30]."の中で定義した。彼らの記述から、完全に匿名な電子マネーモデルが、OkamotoとOhtaが概説した要件を充足させるために充たさなければならない二つの特性を導いた。
 追跡不能性(Untraceability): それぞれの受領トランザクションにおいて、送金者であると見込まれる可能性は誰であっても等確率であること。
 リンク不可能性(Unlinkability): どの二つの出金トランザクションにおいても、それらが同じ人から送られたと証明することは不可能であること。
残念ながら、ビットコインは追跡不能性を満たしていない。

# 4 追跡不可能なトランザクション
## 4.1 文献レビュー
## 4.2 定義
## 4.3 リンク不可能な支払
伝統的なビットコインアドレスは、一度ネットワークに公開（publish）されると、入金のために明確に区別され、着金者とリンクして紐づけられる。もし誰かが「紐づけられていない」トランザクションを受け取りたいと考えた時、自分のアドレスをプライベートな伝達ルートによって伝えなければならない。もし同じ所有者であることが証明できないようにして、異なるトランザクションを受け取りたい場合、全て異なるアドレスを作成して、決して送金者自身と紐づけられないように公開してはいけない。

我々はユーザが単一のアドレスを公開しながら、無条件のリンク不可能な支払いを受けることを可能にする解決策を提案する。CryptoNoteの出力宛先は、着金アドレスと送金者のランダムなデータから計算される公開鍵である。Bitcoinに対する主な利点は、全ての宛先キーがデフォルトでユニークである事である。（送金者が同じ着金者に対して自分のトランザクションごとに同じデータを使用しない限りユニーク性は保たれる）。 したがって、「address reuse」問題はありません。また、特定のアドレスにトランザクションが送信されたか、または2つのアドレスがリンクされているかは、誰も判断できない。

Fig3.

まず、送信者はDiffie-Hellman変換を実行して、自分のデータと着金のアドレスの半分から共有の秘密情報を取得する。次に、共有した秘密とアドレスの後半を使用して、ワンタイムの宛先キーを計算する。 
この2つのステップのために、着金者は2つの異なるec鍵が必要である。そのため、標準のCryptoNoteのアドレスはビットコインウォレットアドレスの2倍長くなる。

標準的なトランザクション処理は次のようになる。

1. AliceはBobに送金したい。Bobは標準アドレスを公開しており、AliceはBobのアドレスから、Bobの公開鍵（A,B）を確認する
1. Aliceはランダムな秘密鍵r ∈ [1; l - 1]を作成する。ワンタイムアドレスの公開鍵PもP = Hs(rA)G+Bとして計算する。
1. Aliceはワンタイムアドレスの公開鍵Pを宛先のキーとして使い、R = rG(Diffie-Hellman変換の一部）をトランザクション内に包含する。固有の公開鍵を持つ他の出力を作成することができることが特筆点である。異なる着金者の鍵（Ai,Bi）は同じrであっても異なるPiを意味する。Fig4.
1. Aliceはトランザクションを送る。
1. Bobは、自分の秘密鍵(a,b)を用いて全てのトランザクションをチェックし、また
　P’ = Hs(aR)G + Bを計算する。もしBobが着金者としてのAliceとの取引がその中にあった場合,
aR = arG = rA and P' = P.となる。
1. Bobは、対応する一時的な秘密鍵x = Hs（aR）+ bをP = xGとして復元することができる。
  xを使ってトランザクションに署名することで、いつでもこの出力を使うことができます。

結果として、Bobは着金を、リンクできないワンタイムの公開鍵と紐づけることになる。

追加のノート：

- Bobはトランザクションを認識するとき、実質Bobはプライベートな情報を半分だけしか利用しない。(a,B)このペアはトラッキングキーとして考えられ、第三者のCarolに渡す事ができる。Bobは明示的にキャロルを信頼する必要はない。何故ならば、Carolはワンタイムの秘密鍵pについて、Bobの完全な秘密鍵(a,b)なしでは復元できない。この方法は、Bobがネットワーク帯域や計算能力（スマートフォン、ハードウェアウォレットなど）がない場合に有用である。

- AliceがBobのアドレスに送金したことを証明したい時、Alicceはrを開示するか、何らかのゼロ知識証明プロトコルを使って、rを知って居ることを示す。（例えば、rを用いてトランザクションに署名する）

- Bobがすべての着金トランザクションがリンク可能である監査互換性のあるアドレスを持つことを望む場合、彼は自分の追跡キーを公開するか、または短縮アドレスを使用することができる。 短縮アドレスはただ一つのec鍵Bを表示し、プロトコルによって必要とされる残りの部分は、a = Hs(B)とA = Hs(B)Gによって計算される。どちらの場合も、全ての人にBobの着金トランザクションを「認識」させることができる。しかし、もちろん、誰も秘密鍵bなしに、内包された通貨を利用することはできない。

## 4.4 ワンタイムリング署名
ワンタイムリング署名に基づいたプロトコルによって、リンク不可能性を達成する。残念ながら、普通の署名においては追跡を可能にしてしまう。この問題に対する我々の解決策は、通常電子マネーシステムにおいて使われるものとは異なる署名方式を用いることである。まず、我々は明示的に電子マネーシステムを参照することなく、アルゴリズムの概要を説明する。ワンタイムリング署名には、（GEN、SIG、VER、LNK）の4つのアルゴリズムが含まれる。

GEN: 公開パラメータを取得し、ecペア（P; x）と公開鍵Iを出力する

SIG: メッセージm、公開鍵{Pi}i≠s,ペア（Ps; xs）を取り、署名σと集合S = S' U {Ps}

VER: メッセージm、セットS、署名σをとり、TRUEまたはFALSEを出力する

LNK: _I_ = {Ii}, 署名σをとり、リンクされたか(linked)と独立(indep)を出力する

プロトコルの背後にあるアイデアはかなり単純である：ユーザは一意の公開鍵ではなく、公開鍵のセットによってチェックできる署名を生成する。 署名者の身元は、所有者が同じ鍵ペアを使用して2番目の署名を生成するまで、公開鍵が設定されている他のユーザと区別できない。

GEN: 署名者は、ランダムな秘密鍵x ∈ [1; l - 1]を計算し、対応する公開鍵P = xGを計算する。 さらに署名者は、key imageと呼ぶ別の公開鍵I = xHp（P）を計算する。
SIG: 署名者は[21]の手法を用いて、非対話型のゼロ知識証明でワンタイムリング署名を生成する。 署名者は、他のユーザの公開鍵Pi、自分の鍵ペア（x; P）およびkey image Iから、nのランダムなサブセットS'を選択する。 0 ≦ s ≦ nの署名者の秘密インデックスSである（その公開鍵がPsであるように）。署名者はランダムな{qi | i = 0 ...n} と、{wi | i = 0 ... n, i ≠ s}を(1 ... l)から取り、次の変換にて申請する

次のステップでは、非対話型の課題を取得する。
  c = Hs(m, L1, ... Ln;R1 ... Rn)

VER: 検証者は署名を以下の逆変換によってチェックする

最終的に、検証者は

<img src="https://latex.codecogs.com/gif.latex?\sum_{i=0}^{n}&space;ci=Hs(m,{L'_{0}},....{L'_{n}},{R'_{0}},....{R'_{n}})&space;\mod&space;l" />

を検証する。等式が正しければ、検証者はLNKアルゴリズムを実行し、等式が誤っていれば署名を拒否する。

LNK：署名者はIが過去の署名で使用されているかどうかをチェックします（これらの値は集合Iに格納される）。 複数の使用は、同じ秘密鍵で2つの署名が作成されたことを意味する。

プロトコルの意味：L変換を適用することによって、署名者は、少なくとも1つのPi = xGであることを彼が知っていることを証明する。 

この証明を反復不可能にするために、I = xHp（P）としてキー画像を導入する。 署名者は、同じ文を証明するために同じ係数（ri; ci）を使用する。
署名者は、少なくとも1つのHp（Pi）= <img src="https://latex.codecogs.com/gif.latex?I\cdot&space;x^{-1}" >である事を知っている。
もしマッピング<img src="https://latex.codecogs.com/gif.latex?x\rightarrow&space;I" >を挿入したとして

1. 誰もキーイメージから公開鍵を復元して、署名者を特定することはできない
1. 署名者は、異なるIと同じxを持つ2つの署名を作ることはできない
完全なセキュリティ分析はAppendix Aにある。